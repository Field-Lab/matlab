function [ta, e_ta] = compute_ta_from_ind(tai, imfolder, zeroval)
%COMPUTE_TA_FROM_IND Computes a triggered average from a matrix of indices
%generated by compute_ta_ind and an events folder.
%
%  TA = COMPUTE_TA_FROM_IND(TAI, IMFOLDER) will use the events stored in
%  the folder IMFOLDER (assumed to be stored by chunks in alphanumerical
%  older, and saved as mat files) and the matrix of indices TAI to
%  calculate a spike-triggered average of the events.
%  
%  TA = COMPUTE_TA_FROM_IND(..., ZEROVAL) speficies the neutral value for
%  this TA computation. For example, it should be 0.5 for white noise
%  movies, 128 for natural scenes, etc. Defaults to 0.5.
%
%  [~, E_TA] = COMPUTE_TA_FROM_IND further returns the standard error 
%  of the mean for the triggered average.

if nargin == 2
    zeroval = 0.5;
end

% First, we need to figure out where all the event chunks are stored, and
% in which chunk we should be looking for each event.

% Get the list of all chunk files
allchunks = dir(fullfile(imfolder, '*.mat'));
nchunks = length(allchunks);

% Open the first one to figure out how many events are stored per chunk
load(fullfile(imfolder, allchunks(1).name));
eventsperchunk = length(frames);

% Event 0 is the special event "no frame" (gray), create it here
eventzero = zeroval*ones(size(frames{1}));

% Figure out where the events of interest are
allevents = sort(unique(tai(:)), 'ascend');
nevents = length(allevents);
if size(allevents, 1) < size(allevents, 2)
    allevents = allevents.';
end
% Check that we can account for all the events that are taken into account
if sum(allevents > nchunks*eventsperchunk)
    error('Number of events expected by the STA and known events do not match')
end
% First column: chunk file; second column: frame in the chunk
alleventlocations = mod(allevents, eventsperchunk);
alleventlocations(alleventlocations == 0) = 120;
alleventlocations = [ceil(allevents/eventsperchunk) ...
    alleventlocations];

% Now we can calculate the TA and its associated error
ta = repmat({zeros(size(frames{1}))}, size(tai,2), 1);
e_ta = repmat({zeros(size(frames{1}))}, size(tai,2), 1);
event_counter = zeros(length(ta), 1);
neventsaveraged = size(tai, 1);

chunkloaded = -1;
for kk = 1:nevents
    % Find which frames the current event contributed to
    [~, framesofinterest] = find(tai == allevents(kk));
    
    % Add the event accordingly to mean and variance
    % Event 0 is a special case handled differently
    if allevents(kk)>0
        
        % We only load a movie chunk if it wasn't already in memory
        if chunkloaded ~= alleventlocations(kk,1)
            load(fullfile(imfolder, allchunks(alleventlocations(kk,1)).name));
            chunkloaded = alleventlocations(kk,1);
        end
        
        % For each time the event contributed, update mean/variance.
        % This is our new sample
        x = frames{alleventlocations(kk,2)} - zeroval;
        for ll=1:length(framesofinterest)
            % Current frame
            cframe = framesofinterest(ll);
            % Update event counter
            event_counter(cframe) = event_counter(cframe) + 1;
            % Running mean and variance
            delta = x - ta{framesofinterest(ll)};
            ta{cframe} = ta{cframe} + delta/event_counter(cframe);
            e_ta{cframe} = e_ta{cframe} + delta.*(x - ta{cframe});
        end
        
    else
        
        % New sample
        x = eventzero - zeroval;
        for ll=1:length(framesofinterest)
            % Current frame
            cframe = framesofinterest(ll);
            % Update event counter
            event_counter(cframe) = event_counter(cframe) + 1;
            % Running mean and variance
            delta = x - ta{framesofinterest(ll)};
            ta{cframe} = ta{cframe} + delta/event_counter(cframe);
            e_ta{cframe} = e_ta{cframe} + delta.*(x - ta{cframe});
        end
        
    end
end

% Normalize things
for kk=1:length(e_ta)
    % Go from M2 to variance
    e_ta{kk} = e_ta{kk} / (event_counter(kk) - 1);
    % And we actually want to return the standard error of the mean
    e_ta{kk} = sqrt(e_ta{kk})/sqrt(neventsaveraged);
end

end % compute_ta_from_ind