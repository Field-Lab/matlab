function [time, ccf] = plot_ccf(datarun, cell_IDs, varargin)
% MY_FUNCTION     This function gets the ACF (if one cell ID given) or CCF (if 2 cell IDs
%                      given) and plots the correlogram
%                 correlation functions are calculated using compute_ccf
%
% usage:  datarun = get_correlation(datarun, cell_IDs, <params>)
%
% arguments:  datarun - datarun struct with field specifying X
%            cell_IDs - single cell (for autocorrelogram) or pair of cells (for cross-correlogram)
%            varargin - struct or list of optional parameters (see below)
%
% outputs:    plot
%
% optional parameters, their default values, and what they specify:
%
% verbose           false               show output
% fig_or_axes       []                  figure or axes to plot in. if 0, make new figure. if empty,
%                                       don't plot.  if -1, plot in current.
%
%
%
% parameters passed on to other functions. if not specified by the user, these parameters are not
% passed.
%       passed to 'compute_ccf':
%                        options.
%
%                         [ dt       -  bin size (s) [offset/128]
%                         [ offset   -  maximum offset for CCF (s) [100e-3]
%                         [ shuffle  -  string to determine type of shuffle
%                                        'none'  - standard CCF   [default]
%                                        'stim' - signal correlations
%                                        'noise' - noise correlations
%                                           Must include 'trial' if latter 
%                                           two options are used.
%                         [ trial    -  trial duration of shuffle
%
%
%
% April 2010, Lauren HRUBY Jepson
%


% SET UP OPTIONAL ARGUMENTS

p = inputParser;

% p.keepUnmatched = true;

% specify list of optional parameters
p.addParamValue('verbose', false);
p.addParamValue('fig_or_axes', []);
p.addParamValue('offset', 100e-3);
p.addParamValue('dt', 100e-3/63);
p.addParamValue('shuffle', 'none');
p.addParamValue('trial', 10);

%p.addParamValue('options', struct('offset',100e-3,'scale','ms','shuffle','none'), @isstruct) %passed to compute_ccf

% resolve user input and default values
p.parse(varargin{:});

% get params struct
params = p.Results;
% options = p.Unmatched;
options = params;
% generate structs to pass on



%% BODY OF THE FUNCTION

% show output
if params.verbose
    disp(['Computing correlation for cell(s) ', num2str(cell_IDs)]);
    start_time = clock; % note when it started
end


% get cell indices
cell_indices = get_cell_indices(datarun, cell_IDs);

spikes{1} = datarun.spikes{cell_indices(1)};

if length(cell_indices) == 1
    %cell_indices = [cell_indices cell_indices];
    spikes{2} = spikes{1};
else
    spikes{2} = datarun.spikes{cell_indices(2)};
end

[ccf, time] = compute_ccf_fix(spikes{1}, spikes{2}, options);

% set up plot axes
plot_axes = set_up_fig_or_axes(params.fig_or_axes);
if ~isempty(plot_axes)
    if length(cell_indices) == 1 || cell_IDs(1) == cell_IDs(2) %autocorrelation, so plot only for time > 0
        plot(1000*time(time>0), ccf(time>0))
    else
        plot(1000*time, ccf)
    end
    
    xlabel('ms')
%     if length(cell_IDs) == 1 || cell_IDs(1) == cell_IDs(2)
%         title(['autocorrelogram for cell ' num2str(cell_IDs)])
%     else
%         title(['cross-correlogram for cells ' num2str(cell_IDs(1)) ', ' num2str(cell_IDs(2))])
%     end
    
end


% display how long it took
if params.verbose
    fprintf(' done (%0.1f seconds)\n',etime(clock,start_time));
end


%% cloog to make off-centering artifact generated by compute_ccf teeny-tiny
% written by MG

function [ccf, time]=compute_ccf_fix(sp1, sp2, options)

    if isfield(options, 'dt')
        dt=options.dt;
    else
        % default number of samples in CCF (taken from compute_ccf)
        N = 63;
        dt = options.offset / N;
    end
        
    bin=dt/.00005;
    options.dt=.00005;

    [tccf, ttime]=compute_ccf(sp1, sp2, options);

    ccf=[];
    m=ceil(length(tccf)/2);
    for i=m+bin/2+1:bin:length(tccf)-bin
        ccf=[ccf mean(tccf(ceil(i:i+bin)))];
    end

    ccf=[mean(tccf(ceil(m-bin/2:m+bin/2))) ccf];

    for i=m-bin/2+1:-bin:bin+1
        ccf=[mean(tccf(ceil(i-bin:i))) ccf];
    end

    time=[dt:dt:options.offset-dt];
    time=sort([-time 0 time]);

    %[ccf, time]=compute_ccf(data.spikes{index1}, data.spikes{index2},options);

end

end



