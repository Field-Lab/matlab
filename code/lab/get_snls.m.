function datarun = get_snls(datarun, cell_spec, varargin)
% get_snls       compute SNLs and store in datarun
%
%   see documentation file "computing SNLs.intaglio"
%
%  NOTE: this code only supports white noise movies generated by obvius
%
%
% usage:  datarun = get_snls(datarun, cell_spec, <params>)
%
% arguments:  datarun - datarun struct
%           cell_spec - which cells (see get_cell_indices for options)
%            <params> - struct or list of optional parameters (see below)
%
% outputs:    datarun - datarun struct with results stored in datarun.stas.snls{}
%
%
% optional parameters, their default values, and what they specify:
%
%
% verbose           true            show output
% movie             []              java movie object specifying stimulus
%                                       if empty, will look in datarun.stimulus.java_movie
%                                       note: if the movie is for a very high dimensional stimulus,
%                                       it is more efficient to compute the movie in advance with this command:
%                                       movie = edu.ucsc.neurobiology.vision.matlab.Matlab.computeMovie(...,
%                                           datarun.stimulus.xml_file,datarun.triggers*datarun.sampling_rate);
% frames            ':'             which frames to use
%                                       see parse_frame_spec for options
% new               false           if SNL already exists, compute a new one?
% stimuli           []              how many stimulus frames to use
%                                       if empty, go until end
% 
% start_time        0               time of the first stimulus frame to use (seconds)
%
%
%
%
%
% 2009-09  gauthier
%


% SET UP OPTIONAL ARGUMENTS

p = inputParser;

% specify list of optional parameters
p.addParamValue('verbose', true);
p.addParamValue('movie', []);
p.addParamValue('frames', ':');
p.addParamValue('new', false);
p.addParamValue('new', false);
p.addParamValue('new', false);

% parameters to be passed on
p.addParamValue('start_stim','default value');
p.addParamValue('end_stim', 'default value');

% resolve user input and default values
p.parse(varargin{:});

% get params struct
params = p.Results;




% identify how many cells need SNLs computed

% get cell indices
cell_indices_ = get_cell_indices(datarun,cell_spec);

% ensure proper fields exist in datarun
if ~isfield(datarun.stas,'snls')
    datarun.stas.snls = cell(length(datarun.cell_ids),1);
else
    if length(datarun.stas.snls) < length(datarun.cell_ids)
        datarun.stas.snls{length(datarun.cell_ids)} =[];
    end
end

% if new computation
if params.new
    % compute for all cells
    cell_indices = cell_indices_;
else
    % otherwise, identify only the cells that need it
    cell_indices = [];
    
    % check each cell
    for cc = 1:length(cell_indices_)
        if isempty(datarun.stas.snls{cell_indices_(cc)})
            cell_indices = [cell_indices cell_indices_(cc)]; %#ok<AGROW>
        end
    end
end

% if none, quit
if isempty(cell_indices)
    return
end





% prepare movie

if isempty(params.movie)
    % if none was specified, get movie from datarun
    if isfield(datarun.stimulus,'java_movie') && ~isempty(datarun.stimulus.java_movie)
        movie = datarun.stimulus.java_movie;
    else
        % if datarun doesn't have a movie, give an error
        error('Stimulus movie not specified.  Use datarun = load_java_movie(datarun,<xml_movie_path>);')
    end
else
    % otherwise, use what was provided
    movie = params.movie;
end





% get STRFs and spike times

% identify refresh time
refresh_time = movie.getRefreshTime/1000;

% note stimulus size
field_width = movie.getWidth;
field_height = movie.getHeight;

% check for consistency
if ~all([field_width field_height] == [datarun.stimulus.field_width datarun.stimulus.field_height])
    error('')
end

% initialize storage variables
spikes = sparse(zeros(movie.size,length(cell_indices)));
rois = sparse(false(field_width*field_height,length(cell_indices)));
strfs = cell(length(cell_indices),1);

% show output
if params.verbose
    T=text_waitbar(sprintf('Getting spikes and STRFs for %d cells...',length(cell_indices)));
    start_time = clock; % note when it started
end

% cycle through each cell
for cc = 1:length(cell_indices)
    
    if params.verbose
        T=text_waitbar(T,(cc)/length(cell_indices));
    end
    
    % get cell index, id
    cell_index = cell_indices(cc);
    cell_id = datarun.cell_ids(cell_index);


    % get spike times

    % compute spike rate at all times
    spike_rate = histc(datarun.spikes{cell_index},datarun.triggers(1):refresh_time:movie.size*refresh_time);
    % store spikes in the relevant region
    spikes(:,cc) = spike_rate;


    % get sig stixels
    switch 1
        case 1 % marks
            sig_stixels = datarun.stas.marks{cell_index};
        case 2 % identify sig stixels now
            sig_stixels = significant_stixels(get_sta(datarun,cell_id));
    end
    % reshape
    sig_stixels = reshape(sig_stixels,[],1);
    % store
    rois(:,cc) = sig_stixels;


    % get STRF

    % get STA
    sta = get_sta(datarun,cell_id);
    % identify STA frames to use
    frames = parse_frame_spec(params.frames,size(sta,4));
    % pare to relevant frames, and pad unused frames with zeros
    padded_sta = zeros(size(sta));
    padded_sta(:,:,:,frames) = sta(:,:,:,frames);
    padded_sta = padded_sta(:,:,:,min(frames):end);
    % reshape, so that first dim is space-color, second dim is time
    sta_r = reshape(padded_sta,[],size(padded_sta,4));
    % pare to relevant region, and reshape
    roi = repmat(full(rois(:,cc)),3,1);
    strf = reshape(sta_r(roi,:),[],1);
    % store
    strfs{cc} = strf;

end

% display how long it took
if params.verbose
    fprintf('done (%0.1f seconds)\n',etime(clock,start_time));
end

% note total number of frames which were used
num_frames = size(padded_sta,4);





% compute and save SNLs

% identify when to start
start_stim = floor(params.start_time/(movie.getRefreshTime/1000));

% compute SNLs
[fit_params,gen_signals,snl_params] = ...
    compute_snls(strfs,spikes,movie,'start_stim',start_stim,'end_stim',end_stim,...
    'rois',rois,'num_frames',num_frames,'verbose',params.verbose);

% identify which frames were used
stim_frames = snl_params.start_stim + num_frames - 1:snl_params.end_stim;

% store in datarun
for cc = 1:length(cell_indices)
    cell_index = cell_indices(cc);
    
    datarun.stas.snls{cell_index}.fit_params = fit_params{cc};
    datarun.stas.snls{cell_index}.gen_signal = gen_signals(:,cc);
    datarun.stas.snls{cell_index}.spikes = spikes(stim_frames,cc);
    
end


