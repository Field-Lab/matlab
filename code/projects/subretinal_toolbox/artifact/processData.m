function processData(dataFolder, logFilePath, processedDataFolder, varargin)
% This function computes the artifact in MEA recordings by averaging a
% number of stimulation pulses. The artifact can be estimated from the raw
% data or from TTX data taken separately. The function first tries to load
% the artifacts from the processedDataFolder folder, and if they cannot be
% found there then it computes them.
% After the artifact has been computed, it is removed from the raw data and
% a new processed data file is created.
% This functions creates a allPulsesTimes.mat file in the root of the
% processedDataFolder, which stores all pulses times for all experiments,
% counted in number of samples from the first pulse in this experiment.
% 
% 
% Parameters:
%   - dataFolder: path to the folder where the raw data is stored.
%   - logFilePath: path to the text log file generated by the LabView VI.
%   Necessary to correctly split the data.
%   - processedDataFolder: path to the folder where the processed data will
%   be stored. Has to be specified, as it is not possible to write the data
%   in the same folder than the raw data and guarantee that weird things
%   will not happen with the file names.
% 
% Aditionnally, a number of parameters/value pairs can be specified to
% tweak processing. They are the following:
%   
%   - visionPath: path to the vision .jar archive.
%   - nTrials: number of trials over which the artifact is averaged, by
%   default 200.
%   - nSkipProcessing: number of pulses skipped in the processing at the
%   beginning of each experiment. By default set to 20. Any missing data is
%   replaced by blank data added after the header of the processed file.
%   - nSkipEstimation: number of pulses skipped for estimation of the
%   artifact.  20 is usually a good number.
%   - saveArtifact: by default set to true, specifies if the artifact
%   should be saved or not. 
%   - smootheData: by default false, if set to true the samples during
%   which the artifact occurs will be blanked out
%   - blankOnly: by default false, if set to true no artifact subtraction
%   will take place and only blanking will happen.
%   - useWhiteNoise: by default true, if set to true the blanked out data
%   is replaced by white noise.  Otherwise it is just zeroed out.
%   - noiseSigma:  standard deviation of the white noise used when blanking
%   out data.
%   - useDiary: if set to true (default) creates an artifact removal log
%   - ttlsPerPulse: number of TTL triggers per artefact
%   - ttlPulseTimes: a cell of kk ttl times vectors, where kk is the number
%   of stimuli in the experiment.
%   - trigToPulseDelay: delay (in samples) between the TTL and the light
%   pulse. 2 (default) is a good value and should be used unless you *know*
%   you want something else.
%
% Version: v6.02 - 27/03/2013
%

%% Global parameters

TARGET_POS_TTL_IN_DATA = 100;

%% Reading the input arguments

% Making sure dataFolder ends by '\' or '/', whichever is right
if dataFolder(end:end)~=filesep
    dataFolder = [dataFolder filesep];
end
if processedDataFolder(end:end)~=filesep
    processedDataFolder = [processedDataFolder filesep];
end


% Setting default values for the optional arguments
if isunix
    visionPath = '/home/ggoetz/Research/Vision/Vision815/Vision.jar';
    visionWritePath = '/home/ggoetz/Research/Eclipse/110314 - Write Data V4/WriteDataFile.jar';
else
    visionPath = '\\badger\Users\ggoetz\Research\Vision\Vision815\Vision.jar';
    visionWritePath = '\\badger\Users\ggoetz\Research\Eclipse\110314 - Write Data V4\WriteDataFile.jar';
end

% Default processing parameters - see documentation to know what they are.
nTrials = 75;
nSkipProcessing = 20;   % Number of pulses skipped at the beginning of the processing
nSkipEstimation = 20;   % Number of pulses skipped at the beginning of the data to estimate artifact
saveArtifact = 1;
smootheData = 0;
blankOnly = 0;
useWhiteNoise = true;
noiseSigma = 5;
useDiary = true;
ttlsPerPulse = 1;
logfiletype = 'matlab'; % Logfile was either generated by Matlab or Labview
trigToPulseDelay = 2;

% If some of those were overridden, reading them now
nbin = length(varargin);
if mod(nbin,2)==1
    err = MException('MATLAB:InvArgIn', ...
        'Unexpected number of arguments');
    throw(err);
end

% Reading the optional input arguments
for kk=1:(nbin/2)
    if ~ischar(varargin{kk*2-1})
        err = MException('MATLAB:InvArgIn',...
            'Unexpected additional property');
        throw(err);
    end
    
    switch lower(varargin{kk*2-1})
        case 'visionpath'
            visionPath = varargin{kk*2};
        case 'ntrials'
            nTrials = varargin{kk*2};
        case 'nskipprocessing'
            nSkipProcessing = varargin{kk*2};
        case 'npskipestimation'
            nSkipEstimation = varargin{kk*2};
        case 'saveartifact'
            saveArtifact = varargin{kk*2};
        case 'smoothedata'
            smootheData = varargin{kk*2};
        case 'blankonly'
            blankOnly = varargin{kk*2};
        case 'usewhitenoise'
            useWhiteNoise = varargin{kk*2};
        case 'noisesigma'
            noiseSigma = varargin{kk*2};
        case 'usediary'
            useDiary = varargin{kk*2};
        case 'logfiletype'
            logfiletype = varargin{kk*2};
        case 'ttlsperpulse'
            ttlsPerPulse = varargin{kk*2};
        case 'ttltimes'
            ttlTimes = varargin{kk*2};
        case 'trigtopulsedelay'
            trigToPulseDelay = varargin{kk*2};
        otherwise
            err = MException('MATLAB:InvArgIn',...
                'Unknown parameter specified');
            throw(err);
    end
end

% If blank only, we don't really need to compute the artefact, so we'll
% decrease the number of steps taken to evaluate it
if blankOnly
    nSkipEstimation = 1;
    nTrials = 1;
end

%% Step 1: reading the input arguments, linking to the data files and 
% getting all the relevant parameters out of the files.

% Linking to the raw file
if ~exist('edu/ucsc/neurobiology/vision/io/RawDataFile','class')
    javaaddpath(visionPath);
end
rawFile = edu.ucsc.neurobiology.vision.io.RawDataFile(dataFolder);
header = rawFile.getHeader();

% Getting the recording parameters from the header file
Fs = header.getSamplingFrequency();

% Creating the new data file
if ~exist(processedDataFolder,'dir')
    mkdir(processedDataFolder);
end
if ~exist('edu/ucsc/neurobiology/vision/io/ModifyRawDataFile','class')
    javaaddpath(visionWritePath);
end
newFile = edu.ucsc.neurobiology.vision.io.ModifyRawDataFile(processedDataFolder, header);

% Setting up the diary if we use it
if useDiary
    prevDiaryState = get(0,'diary');
    if strcmp(prevDiaryState,'off')
        diary([processedDataFolder 'artifact_removal.log'])
    else
        prevDiaryPath = get(0,'DiaryFile');
        diary([processedDataFolder 'artifact_removal.log'])
    end
end


%% Step 2: reading the log file, and finding out how the data is split

% Logfile looks different depending on whether Labview or Matlab generated
% it, eventhough in the end the data in it is pretty much the same.
switch logfiletype
    case 'matlab'
        [M, paramNames, ~, pulseTimes] = readLogFile(logFilePath);
        
        stimType = M(:,ismember(paramNames,'Stimulus Type'));
        nPulses = M(:,ismember(paramNames,'Number of pulses'));
        pulseDurations = M(:,ismember(paramNames,'Pulse Duration'));
        nExperiments = size(nPulses,1);
        expDurations = M(:,ismember(paramNames,'Experiment duration'));

        FExperiments = M(:,ismember(paramNames,'Frequency'));
        expStartSample = M(:,ismember(paramNames,'Start Time'));

    case 'labview'
        M = readLogFileLabview(logFilePath);
        
        stimType = M.stimulus_type;
        nPulses = M.number_of_trials/ttlsPerPulse;
        pulseDurations = M.pulse_durations;
        pulseTimes = M.pulse_times;
        nExperiments = numel(nPulses);
        expDurations = M.experiment_duration;

        FExperiments = M.frequency;
        expStartSample = M.start_time;
        
    otherwise
        err = MException('MATLAB:InvArgIn',...
                'Invalid logfile type.');
        throw(err);
end

% If there was a problem with experiment duration logging, plug in default
% duration and show warning
if isnan(expDurations)
    expDurations(isnan(expDurations)) = 101;
    warning('ProcessGratingsData:ReadLogfile',...
        'Could not read stimuli duration, replaced by default value of 101 sec')
end

% Final parameters
expStartSample = expStartSample*Fs; 
expStartSample = int32(expStartSample);
% number of stimulation samples in each dataset:
expNSamplesStim = round(nPulses./FExperiments)*Fs;

% If TTL pulse times specified, we need to check we got the right structure
% in and it has the right number of experiments
if exist('ttlTimes','var')
    if ~iscell(ttlTimes)
        err = MException('MATLAB:InvArgIn',...
                'ttlTimes should be an array of cells.');
        throw(err);
    end
    if length(ttlTimes) ~= nExperiments 
        err = MException('MATLAB:InvArgIn',...
                'ttlTimes does not appear to have the right number of experiments.');
        throw(err);
    end
end


%% Handling case where operator did not click on "stimulate" right away

% Finding the time of the first pulse
if ~exist('ttlTimes', 'var')
    firstPulseTime = findFirstTTLPulse(1);
else
    ttlTimesCExp = ttlTimes{1};
    firstPulseTime = ttlTimesCExp(1) - TARGET_POS_TTL_IN_DATA;
end

% Moving all the stimuli start times forward by this minus 0.1 second
expStartSample = expStartSample + firstPulseTime - int32(round(Fs/10));

% Setting first start time as 0 or the new start time computed, whichever
% one is bigger
expStartSample(1) = max(0,expStartSample(1));

% Estimating the end of the experiment - giving 1 sec overestimate
expEndSample = expStartSample + int32((expDurations + 1)*Fs);

% Copying the blank initial data if there was any
if expStartSample(1)>0
    nSamplesToCopy = expStartSample(1);
    startSample = 0;
    while nSamplesToCopy>0
        rawData = rawFile.getData(startSample,min(10000,nSamplesToCopy));
        newFile.appendDataToLastFile(rawData);
        nSamplesToCopy = nSamplesToCopy - 10000;
        startSample = startSample + 10000;
    end
end

clear nSamplesToCopy startSample

%% Step 3: For each of of the stimulation parameters, compute the artifact
% skipping the first pulses and remove the artifact from the data, creating
% a new bin file for each stimulation parameter

% Storing all the pulse times
allPulseTimes = struct('experimentID',{},'data',{});

% Computing the average artifact and processing the data
for kk=1:nExperiments
    % Displaying some information
    display(['Processing stimulus ' num2str(kk)])
    
    % Creating the corresponding field in the pulse times structure
    allPulseTimes(kk).experimentID = kk;
    thisExpPulseTimes = [];
    
    %%%%%%%%%%%%%%%%%%%%%% Begin: data processing %%%%%%%%%%%%%%%%%%%%%%%%%
    
    switch (stimType(kk))
        
        case 0
            % If stimulation was pulsed IR there are artifacts to remove
            
            %%%%%%%%%%%%% Preliminary Step: finding exp. start %%%%%%%%%%%%

            display('    Preliminary processing...')

            % Finding the time of the first pulse
            if exist('ttlTimes','var')
                ttlTimesCExp = ttlTimes{kk};
                thisExpStartSample = ttlTimesCExp(1) - TARGET_POS_TTL_IN_DATA;
                thisExpStartSample = max(Fs/2,thisExpStartSample);
            else
                thisExpStartSample = findFirstTTLPulse(kk);
                thisExpStartSample = max(Fs/2,thisExpStartSample);
            end

            %%%%%%%%%%%%%%%%%% Step 1: artifact estimation %%%%%%%%%%%%%%%%

            display('    Artifact estimation...')

            % Computing the artifact
            ah = artifact(dataFolder,FExperiments(kk),...
                          'pulseDurations',pulseDurations(kk,:),...
                          'pulseTimes', pulseTimes(kk,:),...
                          'ttlsPerArtifact', ttlsPerPulse,...
                          'startSampleExperiment',thisExpStartSample,...
                          'visionPath',visionPath,...
                          'nTrials',nTrials,...
                          'nSkip',nSkipEstimation,...
                          'processedFolder',[processedDataFolder 'artifact'],...
                          'saveData',saveArtifact,...
                          'experimentRun',kk,...
                          'useSmoothing',smootheData,...
                          'blankOnly',blankOnly,...
                          'trigToPulseDelay',trigToPulseDelay);

            if exist('ttlTimes','var')
                ah.compute(ttlTimesCExp)
            else
                ah.compute()
            end

            %%%%%%%%%%%%%%%%%% Step 2: artifact removal %%%%%%%%%%%%%%%%%%%
            display('    Removing the artifact from the data...')

            % Creating a new bin file for this stimulation run
            newFile.addFile();

            % Replacing data recorded before the first pulse by blank data
            nSamplesBlankData = thisExpStartSample-expStartSample(kk);
            appendBlankData(nSamplesBlankData);

            % Replacing the data skipped by blank data
            if exist('ttlTimes','var')
                [startSample, pulseTimesSeen] = blankNPulses(...
                    thisExpStartSample, nSkipProcessing, ttlsPerPulse, kk, ttlTimesCExp);
            else
                [startSample, pulseTimesSeen] = blankNPulses(...
                    thisExpStartSample, nSkipProcessing, ttlsPerPulse, kk);
            end
            
            npRemoved = length(pulseTimesSeen);
            if npRemoved~=nSkipProcessing
                display(['    Warning: Could not blank enough pulses for stimulus '...
                    num2str(kk-1)]);
            end
            thisExpPulseTimes = [thisExpPulseTimes; pulseTimesSeen];

            % Processing pulse by pulse the raw data
            if exist('ttlTimes','var')
                [startSample, pulseTimesSeen] = processNPulses(startSample,...
                    nPulses(kk)-nSkipProcessing, ttlsPerPulse, kk, ttlTimesCExp);
            else
                [startSample, pulseTimesSeen] = processNPulses(startSample,...
                    nPulses(kk)-nSkipProcessing, ttlsPerPulse, kk);
            end
            
            npProcessed = length(pulseTimesSeen);
            thisExpPulseTimes = [thisExpPulseTimes; pulseTimesSeen];
            
           
            % Adjusting the pulse times matrix
            thisExpPulseTimes = thisExpPulseTimes - thisExpStartSample; 

            display(['    Pulses processed: ' num2str(npRemoved+npProcessed)...
                ', Pulses cleaned: ' num2str(npProcessed)])
            %%%%%%%%%%%% End of processing for this stimulus %%%%%%%%%%%%%%
            
            
        case 1
            % If stimulation was pulsed visible we need to keep track of
            % the pulse times.
            % There can also be tiny artifacts due to black not being
            % completely black so we remove these too, but we don't use
            % smoothing.
            % We do not blank the initial pulses either.
            
            %%%%%%%%%%%%% Preliminary Step: finding exp. start %%%%%%%%%%%%

            display('    Preliminary processing...')

            % Finding the time of the first pulse
            if exist('ttlTimes','var')
                ttlTimesCExp = ttlTimes{kk};
                thisExpStartSample = ttlTimesCExp(1);
            else
                thisExpStartSample = findFirstTTLPulse(kk);
                thisExpStartSample = max(Fs/2,thisExpStartSample);
            end
            
            %%%%%%%%%%%%%%%%%% Step 1: artifact estimation %%%%%%%%%%%%%%%%

            display('    Artifact estimation...')

            % Computing the artifact
            ah = artifact(dataFolder,FExperiments(kk),...
                          'pulseDurations',pulseDurations(kk,:),...
                          'pulseTimes', pulseTimes(kk,:),...
                          'ttlsPerArtifact', ttlsPerPulse,...
                          'startSampleExperiment',thisExpStartSample,...
                          'visionPath',visionPath,...
                          'nTrials',nTrials,...
                          'nSkip',nSkipEstimation,...
                          'processedFolder',[processedDataFolder 'artifact'],...
                          'saveData',saveArtifact,...
                          'experimentRun',kk,...
                          'useSmoothing',false,...
                          'blankOnly',false);

            if exist('ttlTimes','var')
                ah.compute(ttlTimesCExp)
            else
                ah.compute()
            end

            %%%%%%%%%%%%%%%%%% Step 2: artifact removal %%%%%%%%%%%%%%%%%%%
            display('    Removing the artifact from the data...')

            % Creating a new bin file for this stimulation run
            newFile.addFile();

            % Replacing data recorded before the first pulse by blank data
            nSamplesBlankData = thisExpStartSample-expStartSample(kk);
            appendBlankData(nSamplesBlankData);

            % Processing pulse by pulse the raw data
            if exist('ttlTimes','var')
                [startSample, pulseTimesSeen] = processNPulses(startSample,...
                    nPulses(kk)-nSkipProcessing, ttlsPerPulse, kk, ttlTimesCExp);
            else
                [startSample, pulseTimesSeen] = processNPulses(startSample,...
                    nPulses(kk)-nSkipProcessing, ttlsPerPulse, kk);
            end
            
            npProcessed = length(pulseTimesSeen);
            thisExpPulseTimes = [thisExpPulseTimes; pulseTimesSeen];
           
            % Adjusting the pulse times matrix
            thisExpPulseTimes = thisExpPulseTimes - thisExpStartSample; 

            display(['    Pulses processed: ' num2str(npProcessed)...
                ', Pulses cleaned: ' num2str(npProcessed)])
            %%%%%%%%%%%% End of processing for this stimulus %%%%%%%%%%%%%%
            
        otherwise
            % If stimulation was not one of the above we just copy the data. 
            % There is no pulse time information stored, no checking of the number
            % of pulses delivered.
            startSample = copyData(expStartSample(kk),pulseDuration(kk),expID);

    end
    
    %%%%%%%%%%%%%%%%% Standard tasks, done for each stim type %%%%%%%%%%%%%
    
    % Filling in the pulse times matrix
    allPulseTimes(kk).data = double([thisExpPulseTimes; expNSamplesStim(kk)]);
    
    % Replacing the contrast measurement data by blank data
    display('    Removing the contrast measurement data');
    blankEnd(startSample,kk);
    
    display(['    Stimulus ' num2str(kk) ' processed correctly.'])
    %%%%%%%%%%%%%%%%%%%%%%% End: data processing %%%%%%%%%%%%%%%%%%%%%%%%%%
end

% Updating the number of samples in the new file - TODO: is it useful?
% newFile.setNumberOfSamples(sum((nPulses - nSkipProcessing)./FExperiments*Fs));

% Closing the files
newFile.close();
rawFile.close();

% Saving the pulse times
save([processedDataFolder 'allPulseTimes'],'allPulseTimes')

% Resetting the diary to its previous state
if useDiary
    if strcmp(prevDiaryState,'off')
        diary off
    else
        diary(prevDiaryPath);
    end
end



%%%%%%%%%%%%%%%%%%%%%%%%%% Auxiliary functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

function tt = findFirstTTLPulse(expID)
    % This function finds the time of the first TTL pulse for the 
    % experiment expID

    tt = 0;
    data = rawFile.getData(expStartSample(expID),floor(Fs/FExperiments(expID)));
    triggerPosition = findAllTTLPulses(data(:,1));
    while isempty(triggerPosition)
        tt = tt + floor(Fs/FExperiments(expID));
        data = rawFile.getData(expStartSample(expID)+...
            tt,floor(Fs/FExperiments(expID)));
        triggerPosition = findAllTTLPulses(data(:,1));
    end
    triggerPosition = triggerPosition(1);

    % Adjusting the experiment start time so that the first pulse
    % happens 100 samples after the beginning of the experiment
    tt = tt + expStartSample(expID) + triggerPosition - TARGET_POS_TTL_IN_DATA;

end % findFirstTTLPulse

function appendBlankData(nSamps)
    % This function appends nSamps samples of blank data at the end of the
    % last bin file.

    if nSamps>0
        while nSamps>0
            if useWhiteNoise
                blankData = int16([zeros(min(nSamps,10000),1)...
                    randn(min(nSamps,10000),512)*noiseSigma]);
            else
                blankData = zeros(min(nSamps,10000),513);
            end
            newFile.appendDataToLastFile(blankData);
            nSamps = nSamps - 10000;
        end
    end    
    
end % appendBlankData

function [tt, pTimes] = blankNPulses(tt,np,ttlpp,expID,expttlpt)
    % This function blanks the np pulses that happen after stample tt
    % It returns a matrix pTimes of indexes where the pulses were found
    % as well as the index of the last sample read, tt.
    % Each pulses consists of ttlpp TTL pulses.
    % Blanking the pulses has to be done in several steps, otherwise out 
    % of memory error
    %
    % Parameters:
    %   - tt: starting sample in the dataset
    %   - np: number of trials to process
    %   - ttlpp: number of ttl pulses in each trials
    %   - expID: ID of the experiment
    %   - expttlpt: optional. If specified, corresponds to manual
    %   specification of the TTL pulse times. Trigger data will then not be
    %   used at all.
    

    pTimes = [];
    pulsesSkipped = 0;
    
    while pulsesSkipped < np
        if exist('expttlpt','var')
            isPulse = expttlpt(logical((expttlpt>=tt).*...
                (expttlpt<(tt + ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA)))) - tt;
        else
            trigger = rawFile.getData(0,tt,ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA);
            isPulse = findAllTTLPulses(trigger);
        end

        nSamplesBlank = ah.nSamplesPulse;
        
        if ~isempty(isPulse)
            % Updating pulse counter and pulse times matrix
            pulsesSkipped = pulsesSkipped + 1;
            pTimes = [pTimes; (tt+isPulse(1))];
            
            % Aligning the first TTL pulse in the recording
            alignmentOffset = isPulse(1) - TARGET_POS_TTL_IN_DATA;
            nSamplesBlank = nSamplesBlank + alignmentOffset;
            
            % Determining if the next pulse is there too early or not
            % We're not trying to correct the position of the pointer here,
            % only making sure we're not deleting one more pulse than we 
            % should be by mistake.
            if alignmentOffset ~= 0
                if exist('expttlpt','var')
                    isPulse = expttlpt(logical((expttlpt>=tt + alignmentOffset).*...
                        (expttlpt<(tt + alignmentOffset + ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA)))) ...
                        - tt;
                else
                    trigger = rawFile.getData(0,tt+alignmentOffset,...
                        ah.nSamplesPulse  + TARGET_POS_TTL_IN_DATA);
                    isPulse = findAllTTLPulses(trigger);
                end
            end
            
            % Consequently: if we see we have too many TTLs in the trigger,
            % we shorten the recording we're trying to process accordingly.
            if length(isPulse) > ttlpp
                overshootOffset = ah.nSamplesPulse - isPulse(ttlpp+1) + TARGET_POS_TTL_IN_DATA;
                nSamplesBlank = nSamplesBlank - overshootOffset;
            end
        
        end

        if useWhiteNoise
            newFile.appendDataToLastFile(int16([
                zeros(nSamplesBlank,1) ...
                randn(nSamplesBlank,512)*noiseSigma]));
        else
            newFile.appendDataToLastFile(zeros(nSamplesBlank,513));
        end

        % Incrementing the sample counter
        tt = tt + nSamplesBlank;
        
        % Checking that we're not reading data from the next stimulus
        if tt >= expEndSample(expID)
            display(['    WARNING: strange things happened for stimuli '...
                num2str(expID-1)])
            break;
        end
    end
    
end % blankNPulses

function [tt, pTimes] = processNPulses(tt,np,ttlpp,expID,expttlpt)
    % This function removes the artifact from the np pulses found after
    % sample tt. Each pulse consists of ttlpp TTL pulses.
    % It returns the index of the last sample read, tt, as well as a matrix
    % of pulse times.
    %
    % Parameters:
    %   - tt: starting sample in the dataset
    %   - np: number of trials to process
    %   - ttlpp: number of ttl pulses in each trials
    %   - expID: ID of the experiment
    %   - expttlpt: optional. If specified, corresponds to manual
    %   specification of the TTL pulse times. Trigger data will then not be
    %   used at all.
    
    pTimes = [];
    pulsesSeen = 0;
    while pulsesSeen < np
        % First need to figure out where the data we need is, and check
        % that there was a trigger.
        if exist('expttlpt','var')
            isPulse = expttlpt(logical((expttlpt>=tt).*...
                (expttlpt<(tt + ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA))));
            if ~isempty(isPulse)
                isPulse = isPulse - tt;
            end
        else
            trigger = rawFile.getData(0,tt,ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA);
            isPulse = findAllTTLPulses(trigger);
        end
        
        if isempty(isPulse)
            display(sprintf('\tMissed pulse: sample %d, seen so far: %d',...
                tt, pulsesSeen));
            procData = rawFile.getData(tt,ah.nSamplesPulse);
        else
            pulsesSeen = pulsesSeen + 1;
            pTimes = [pTimes; (tt+isPulse(1))];
            
            nPointsToGetForRawData = ah.nSamplesPulse;
            
            % Aligning the first TTL pulse in the recording
            alignmentOffset = isPulse(1) - TARGET_POS_TTL_IN_DATA;
            nPointsToGetForRawData = nPointsToGetForRawData + alignmentOffset;
            
            % Determining if the next pulse is there too early or not
            % We're not trying to correct the position of the pointer here,
            % only making sure we're not processing one more pulse than we 
            % should be by mistake.
            if alignmentOffset ~= 0
                if exist('expttlpt','var')
                    isPulse = expttlpt(logical((expttlpt>=tt + alignmentOffset).*...
                        (expttlpt<(tt + alignmentOffset + ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA)))) ...
                        - tt;
                else
                    trigger = rawFile.getData(0,tt+alignmentOffset,...
                        ah.nSamplesPulse  + TARGET_POS_TTL_IN_DATA);
                    isPulse = findAllTTLPulses(trigger);
                end
            end
            
            if length(isPulse) > ttlpp
                overshootOffset = ah.nSamplesPulse - isPulse(ttlpp+1) + TARGET_POS_TTL_IN_DATA;
                nPointsToGetForRawData = nPointsToGetForRawData - overshootOffset;
            end
            
            rawData = rawFile.getData(tt+alignmentOffset,nPointsToGetForRawData);

            % Removing the artifact
            if exist('expttlpt','var')
                procData = ah.processData(rawData, double(isPulse(1)));
            else
                procData = ah.processData(rawData);
            end
            
        end
        
        % Writing the data
        newFile.appendDataToLastFile(procData);

        % Incrementing the sample counter
        tt = tt + int32(size(procData,1));

        % Checking that we're not processing data that belongs to the next stimuli
        if tt>=expEndSample(expID)
            display(['    WARNING: stimulation pulses seem to be missing in stimulus '...
                num2str(expID-1)])
            break;
        end
        
    end
    
end % processNPulses

function tt = copyData(tt,dur,expID)
    % This function copies the dur seconds of data following sample tt
    % at the end of the last new bin file.
    
    nSamplesPulse = Fs;
    secondsProcessed = 0;
    while secondsProcessed < dur
        % Getting the data
        rawData = rawFile.getData(tt,nSamplesPulse); 

        % Writing the data
        backupFile.appendDataToLastFile(rawData);

        % Incrementing the sample and pulses processed counters
        tt = tt + nSamplesPulse;
        secondsProcessed = secondsProcessed + 1;

        % Checking that we're not reading data from the next stimulus
        if tt >= expEndSample(expID)
            display(['    WARNING: strange things happened for ...stimuli '...
                num2str(expID-1)])
            break;
        end
    end
end % copyData

function blankEnd(tt,expID)
    % This function blanks everything that happened between sample tt
    % and the next stimulus. Don't need to worry about it for the last
    % stimulus.
    
if expID==length(expStartSample)
    return;
else
    nSamps = expStartSample(expID+1)-tt;
end

if nSamps>0
    while nSamps>0
        if useWhiteNoise
            blankData = int16(ones(min(nSamps,10000),1)*...
                double(rawData(end,:)) + ...
                [zeros(min(nSamps,10000),1) ...
                randn(min(nSamps,10000),512)*noiseSigma]);
        else
            blankData = int16(ones(min(nSamps,10000),1)*...
                double(rawData(end,:)));
        end
        newFile.appendDataToLastFile(blankData);
        nSamps = nSamps - 10000;
    end
else
    display(['    Warning: contrast measurement did not seem to happen between stimuli '...
        num2str(expID-1) ' and ' num2str(expID)]);
end
    
end %blankEnd

function ttl_pt = findAllTTLPulses(trigger)
    % This function finds all the TTL pulses in a trigger
    
    ttl_pt = find(diff(trigger)==-2048);
    if trigger(1) == -2048
        ttl_pt = [0 ttl_pt];
    end
    ttl_pt = int32(ttl_pt);

end % findAllTTLPulses

end % processData
