function processGratingsData(dataFolder, logFilePath, processedDataFolder, varargin)
% This function computes the artifact in MEA recordings by averaging a
% number of stimulation pulses. The artifact can be estimated from the raw
% data or from TTX data taken separately. The function first tries to load
% the artifacts from the processedDataFolder folder, and if they cannot be
% found there then it computes them.
% After the artifact has been computed, it is removed from the raw data and
% a new processed data file is created.
% This functions creates a allPulsesTimes.mat file in the root of the
% processedDataFolder, which stores all pulses times for all experiments,
% counted in number of samples from the first pulse in this experiment.
% 
% 
% Parameters:
%   - dataFolder: path to the folder where the raw data is stored.
%   - logFilePath: path to the text log file generated by the LabView VI.
%   Necessary to correctly split the data.
%   - processedDataFolder: path to the folder where the processed data will
%   be stored. Has to be specified, as it is not possible to write the data
%   in the same folder than the raw data and guarantee that weird things
%   won't happen with the file names.
% 
% Aditionnally, a number of parameters/value pairs can be specified to
% tweak processing. They are the following:
%   
%   - TTXdataFolder: if TTX data is to be used for artifact estimation,
%   this should be specified. Otherwise the artifact is estimated by
%   averaging the raw data.
%   - TTXlogFilePath: if specified, the script will check that the
%   stimulation parameters used for the TTX data and for the non TTX data
%   are the same and will throw an error if they were not. 
%   If not specified it will assume they are, so it's a good idea to
%   specify this if TTX data is to be used for the processing.
%   - visionPaht: path to the vision .jar archive.
%   - nTrials: number of trials over which the artifact is averaged, by
%   default 200.
%   - nSkipProcessing: number of pulses skipped in the processing at the
%   beginning of each experiment. By default set to 20. Any missing data is
%   replaced by blank data added after the header of the processed file.
%   - nSkipEstimation: number of pulses skipped for estimation of the
%   artifact.  20 is usually a good number.
%   - saveArtifact: by default set to true, specifies if the artifact
%   should be saved or not. 
%   - smootheData: by default false, if set to true the samples during
%   which the artifact occurs will be blanked out
%   - useWhiteNoise: by default true, if set to true the blanked out data
%   is replaced by white noise.  Otherwise it is just zeroed out.
%   - noiseSigma:  standard deviation of the white noise used when blanking
%   out data.
%   - useDiary: if set to true (default) creates an artifact removal log
%
% Version: v5.00 - 10/04/2012
%

%% Global parameters

TARGET_POS_TTL_IN_DATA = 100;

%% Reading the input arguments

% Making sure dataFolder ends by '\' or '/', whichever is right
if dataFolder(end:end)~=filesep
    dataFolder = [dataFolder filesep];
end
if processedDataFolder(end:end)~=filesep
    processedDataFolder = [processedDataFolder filesep];
end


% Setting default values for the optional arguments
TTXlogFilePath = logFilePath;
TTXdataFolder = dataFolder;
if isunix
    visionPath = '/home/ggoetz/Research/Vision/Vision815/Vision.jar';
    visionWritePath = '/home/ggoetz/Research/Eclipse/110314 - Write Data V4/WriteDataFile.jar';
else
    visionPath = '\\badger\Users\ggoetz\Research\Vision\Vision815\Vision.jar';
    visionWritePath = '\\badger\Users\ggoetz\Research\Eclipse\110314 - Write Data V4\WriteDataFile.jar';
end

% Default processing parameters
nTrials = 100;
nSkipProcessing = 5;   % Number of pulses skipped at the beginning of the processing
nSkipEstimation = 5;   % Number of pulses skipped at the beginning of the data to estimate artifact
saveArtifact = 1;
smootheData = 1;
useWhiteNoise = true;
noiseSigma = 5;
useDiary = true;
ttlsPerPulse = 1;

% If some of those were overridden, reading them now
nbin = length(varargin);
if mod(nbin,2)==1
    err = MException('MATLAB:InvArgIn', ...
        'Unexpected number of arguments');
    throw(err);
end

% Reading the optional input arguments
for kk=1:(nbin/2)
    if ~ischar(varargin{kk*2-1})
        err = MException('MATLAB:InvArgIn',...
            'Unexpected additional property');
        throw(err);
    end
    
    switch lower(varargin{kk*2-1})
        case 'ttxlogfilepath'
            TTXlogFilePath = varargin{kk*2};
        case 'ttxdatafolder'
            TTXdataFolder = varargin{kk*2};
        case 'visionpath'
            visionPath = varargin{kk*2};
        case 'ntrials'
            nTrials = varargin{kk*2};
        case 'nskipprocessing'
            nSkipProcessing = varargin{kk*2};
        case 'npskipestimation'
            nSkipEstimation = varargin{kk*2};
        case 'saveartifact'
            saveArtifact = varargin{kk*2};
        case 'smoothedata'
            smootheData = varargin{kk*2};
        case 'usewhitenoise'
            useWhiteNoise = varargin{kk*2};
        case 'noisesigma'
            noiseSigma = varargin{kk*2};
        case 'usediary'
            useDiary = varargin{kk*2};
        case 'ttlsperpulse'
            ttlsPerPulse = varargin{kk*2};
        otherwise
            err = MException('MATLAB:InvArgIn',...
                'Unknown parameter specified');
            throw(err);
    end
end

%% Step 1: reading the input arguments, linking to the data files and 
% getting all the relevant parameters out of the files.

% Linking to the raw file
if ~exist('edu/ucsc/neurobiology/vision/io/RawDataFile','class')
    javaaddpath(visionPath);
end
rawFile = edu.ucsc.neurobiology.vision.io.RawDataFile(dataFolder);
header = rawFile.getHeader();

% Getting the recording parameters from the header file
Fs = header.getSamplingFrequency();

% Creating the new data file
if ~exist(processedDataFolder,'dir')
    mkdir(processedDataFolder);
end
if ~exist('edu/ucsc/neurobiology/vision/io/ModifyRawDataFile','class')
    javaaddpath(visionWritePath);
end
newFile = edu.ucsc.neurobiology.vision.io.ModifyRawDataFile(processedDataFolder, header);

% Setting up the diary if we use it
if useDiary
    prevDiaryState = get(0,'diary');
    if strcmp(prevDiaryState,'off')
        diary([processedDataFolder 'artifact_removal.log'])
    else
        prevDiaryPath = get(0,'DiaryFile');
        diary([processedDataFolder 'artifact_removal.log'])
    end
end


%% Step 2: reading the log file, and finding out how the data is split
M = readLogFileLabview(logFilePath);

% If the TTX log file was also specified, we check that it contains the
% same information before losing data processing time
if ~strcmp(logFilePath,TTXlogFilePath)
   MTTX = readLogFile(TTXLogFilePath);
   if sum(size(M)~=size(MTTX))
       err = MException('MATLAB:Logfiles Mismatch',...
           'Non-TTX and TTX experiment log files do not match');
       throw(err);
   else if sum(sum(M~=MTTX))
       err = MException('MATLAB:Logfiles Mismatch',...
           'Non-TTX and TTX experiment log files do not match');
       throw(err);
       end
   end
end

% If it was ok we can go on with the processing
stimType = M.stimulus_type;
nPulses = M.number_of_trials/ttlsPerPulse;
pulseDurations = M.pulse_durations;
pulseTimes = M.pulse_times;
nExperiments = numel(nPulses);
expDurations = M.experiment_duration;
% If there was a problem with experiment duration logging, plug in default
% duration and show warning
if isnan(expDurations)
    expDurations(isnan(expDurations)) = 101;
    warning('ProcessGratingsData:ReadLogfile',...
        'Could not read stimuli duration, replaced by default value of 101 sec')
end

FExperiments = M.frequency;

expStartSample = M.start_time;
expStartSample = expStartSample*Fs; 
expStartSample = int32(expStartSample);

% number of stimulation samples in each dataset
expNSamplesStim = round(nPulses./FExperiments)*Fs;

%% Handling case where operator didn't click on "stimulate" right away

% Finding the time of the first pulse
firstPulseTime = findFirstTTLPulse(1);

% Moving all the stimuli start times forward by this minus 0.1 second
expStartSample = expStartSample + firstPulseTime - int32(round(Fs/10));

% Setting first start time as 0 or the new start time computed, whichever
% one is bigger
expStartSample(1) = max(0,expStartSample(1));

% Estimating the end of the experiment - giving 1 sec overestimate
expEndSample = expStartSample + int32((expDurations + 1)*Fs);

% Copying the blank initial data if there was any
if expStartSample(1)>0
    nSamplesToCopy = expStartSample(1);
    startSample = 0;
    while nSamplesToCopy>0
        rawData = rawFile.getData(startSample,min(10000,nSamplesToCopy));
        newFile.appendDataToLastFile(rawData);
        nSamplesToCopy = nSamplesToCopy - 10000;
        startSample = startSample + 10000;
    end
end

clear nSamplesToCopy startSample

%% Step 3: For each of of the stimulation parameters, compute the artifact
% skipping the first pulses and remove the artifact from the data, creating
% a new bin file for each stimulation parameter

% Storing all the pulse times
allPulseTimes = struct('experimentID',{},'data',{});

% Computing the average artifact and processing the data
for kk=1:nExperiments
    % Displaying some information
    display(['Processing stimulus ' num2str(kk)])
    
    % Creating the corresponding field in the pulse times structure
    allPulseTimes(kk).experimentID = kk;
    thisExpPulseTimes = [];
    
    %%%%%%%%%%%%%%%%%%%%%% Begin: data processing %%%%%%%%%%%%%%%%%%%%%%%%%
    
    switch (stimType(kk))
        
        case 0
            % If stimulation was pulsed IR there are artifacts to remove
            
            %%%%%%%%%%%%% Preliminary Step: finding exp. start %%%%%%%%%%%%

            display('    Preliminary processing...')

            % Finding the time of the first pulse
            thisExpStartSample = findFirstTTLPulse(kk);
            thisExpStartSample = max(Fs/2,thisExpStartSample);

            %%%%%%%%%%%%%%%%%% Step 1: artifact estimation %%%%%%%%%%%%%%%%

            display('    Artifact estimation...')

            % Computing the artifact
            ah = artifact_gratings(dataFolder,FExperiments(kk),...
                        'pulseDurations',pulseDurations(kk,:),...
                        'pulseTimes', pulseTimes(kk,:),...
                        'ttlsPerArtifact', ttlsPerPulse,...
                        'startSampleExperiment',thisExpStartSample,...
                        'visionPath',visionPath,...
                        'nTrials',nTrials,...
                        'nSkip',nSkipEstimation,...
                        'processedFolder',[processedDataFolder 'artifact'],...
                        'saveData',saveArtifact,...
                        'experimentRun',kk,...
                        'useSmoothing',smootheData);

            ah.compute()

            %%%%%%%%%%%%%%%%%% Step 2: artifact removal %%%%%%%%%%%%%%%%%%%
            display('    Removing the artifact from the data...')

            % Creating a new bin file for this stimulation run
            newFile.addFile();

            % Replacing data recorded before the first pulse by blank data
            nSamplesBlankData = thisExpStartSample-expStartSample(kk);
            appendBlankData(nSamplesBlankData);

            % Replacing the data skipped by blank data
            [startSample, pulseTimesSeen] = blankNPulses(...
                thisExpStartSample, nSkipProcessing, ttlsPerPulse, kk);
            
            npRemoved = length(pulseTimesSeen);
            if npRemoved~=nSkipProcessing
                display(['    Warning: Could not blank enough pulses for stimulus '...
                    num2str(kk-1)]);
            end
            thisExpPulseTimes = [thisExpPulseTimes; pulseTimesSeen];

            % Processing pulse by pulse the raw data
            [startSample, pulseTimesSeen] = processNPulses(startSample,...
                nPulses(kk)-nSkipProcessing, ttlsPerPulse, kk);
            
            npProcessed = length(pulseTimesSeen);
            thisExpPulseTimes = [thisExpPulseTimes; pulseTimesSeen];
            
           
            % Adjusting the pulse times matrix
            thisExpPulseTimes = thisExpPulseTimes - thisExpStartSample; 

            display(['    Pulses processed: ' num2str(npRemoved+npProcessed)...
                ', Pulses cleaned: ' num2str(npProcessed)])
            %%%%%%%%%%%% End of processing for this stimulus %%%%%%%%%%%%%%
            
            
        otherwise
            % If stimulation was not one of the above we just copy the data. 
            % There is no pulse time information stored, no checking of the number
            % of pulses delivered.
            startSample = copyData(expStartSample(kk),pulseDuration(kk),expID);

    end
    
    %%%%%%%%%%%%%%%%% Standard tasks, done for each stim type %%%%%%%%%%%%%
    
    % Filling in the pulse times matrix
    allPulseTimes(kk).data = double([thisExpPulseTimes; expNSamplesStim(kk)]);
    
    % Replacing the contrast measurement data by blank data
    display('    Removing the contrast measurement data');
    blankEnd(startSample,kk);
    
    display(['    Stimulus ' num2str(kk) ' processed correctly.'])
    %%%%%%%%%%%%%%%%%%%%%%% End: data processing %%%%%%%%%%%%%%%%%%%%%%%%%%
end

% Updating the number of samples in the new file - TODO: is it useful?
% newFile.setNumberOfSamples(sum((nPulses - nSkipProcessing)./FExperiments*Fs));

% Closing the files
newFile.close();
rawFile.close();

% Saving the pulse times
save([processedDataFolder 'allPulseTimes'],'allPulseTimes')

% Resetting the diary to its previous state
if useDiary
    if strcmp(prevDiaryState,'off')
        diary off
    else
        diary(prevDiaryPath);
    end
end



%%%%%%%%%%%%%%%%%%%%%%%%%% Auxiliary functions %%%%%%%%%%%%%%%%%%%%%%%%%%%%

function tt = findFirstTTLPulse(expID)
    % This function finds the time of the first TTL pulse for the 
    % experiment expID

    tt = 0;
    data = rawFile.getData(expStartSample(expID),floor(Fs/FExperiments(expID)));
    triggerPosition = findAllTTLPulses(data(:,1));
    while isempty(triggerPosition)
        tt = tt + floor(Fs/FExperiments(expID));
        data = rawFile.getData(expStartSample(expID)+...
            tt,floor(Fs/FExperiments(expID)));
        triggerPosition = findAllTTLPulses(data(:,1));
    end
    triggerPosition = triggerPosition(1);

    % Adjusting the experiment start time so that the first pulse
    % happens 100 samples after the beginning of the experiment
    tt = tt + expStartSample(expID) + triggerPosition - TARGET_POS_TTL_IN_DATA;

end % findFirstTTLPulse

function appendBlankData(nSamps)
    % This function appends nSamps samples of blank data at the end of the
    % last bin file.

    if nSamps>0
        while nSamps>0
            if useWhiteNoise
                blankData = int16([zeros(min(nSamps,10000),1)...
                    randn(min(nSamps,10000),512)*noiseSigma]);
            else
                blankData = zeros(min(nSamps,10000),513);
            end
            newFile.appendDataToLastFile(blankData);
            nSamps = nSamps - 10000;
        end
    end    
    
end % appendBlankData

function [tt, pTimes] = blankNPulses(tt,np,ttlpp,expID)
    % This function blanks the np pulses that happen after stample tt
    % It returns a matrix pTimes of indexes where the pulses were found
    % as well as the index of the last sample read, tt.
    % Each pulses consists of ttlpp TTL pulses.
    % Blanking the pulses has to be done in several steps, otherwise out 
    % of memory error

    pTimes = [];
    pulsesSkipped = 0;
    
    while pulsesSkipped < np
        trigger = rawFile.getData(0,tt,ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA);
        isPulse = findAllTTLPulses(trigger);

        nSamplesBlank = ah.nSamplesPulse;
        
        if ~isempty(isPulse)
            % Updating pulse counter and pulse times matrix
            pulsesSkipped = pulsesSkipped + 1;
            pTimes = [pTimes; (tt+isPulse(1))];
            
            % Aligning the first TTL pulse in the recording
            alignmentOffset = isPulse(1) - TARGET_POS_TTL_IN_DATA;
            nSamplesBlank = nSamplesBlank + alignmentOffset;
            
            % Determining if the next pulse is there too early or not
            if alignmentOffset ~= 0
                trigger = rawFile.getData(0,tt+alignmentOffset,ah.nSamplesPulse  + TARGET_POS_TTL_IN_DATA);
                isPulse = findAllTTLPulses(trigger);
            end
            
            if length(isPulse) > ttlpp
                overshootOffset = ah.nSamplesPulse - isPulse(ttlpp+1) + TARGET_POS_TTL_IN_DATA;
                nSamplesBlank = nSamplesBlank - overshootOffset;
            end
        
        end

        if useWhiteNoise
            newFile.appendDataToLastFile(int16([
                zeros(nSamplesBlank,1) ...
                randn(nSamplesBlank,512)*noiseSigma]));
        else
            newFile.appendDataToLastFile(zeros(nSamplesBlank,513));
        end

        % Incrementing the sample counter
        tt = tt + nSamplesBlank;
        
        % Checking that we're not reading data from the next stimulus
        if tt >= expEndSample(expID)
            display(['    WARNING: strange things happened for stimuli '...
                num2str(expID-1)])
            break;
        end
    end
    
end % blankNPulses

function [tt, pTimes] = processNPulses(tt,np,ttlpp,expID)
    % This function removes the artifact from the np pulses found after
    % sample tt. Each pulse consists of ttlpp TTL pulses.
    % It returns the index of the last sample read, tt, as well as a matrix
    % of pulse times.
    
    pTimes = [];
    pulsesSeen = 0;
    while pulsesSeen < np
        % First need to figure out where the data we need is
        trigger = rawFile.getData(0,tt,ah.nSamplesPulse + TARGET_POS_TTL_IN_DATA);
        
        % Checking if there is a trigger
        isPulse = findAllTTLPulses(trigger);
        
        if isempty(isPulse)
            display(sprintf('\tMissed pulse: sample %d, seen so far: %d',...
                tt, pulsesSeen));
            procData = rawFile.getData(tt,ah.nSamplesPulse);
        else
            pulsesSeen = pulsesSeen + 1;
            pTimes = [pTimes; (tt+isPulse(1))];
            
            nPointsToGetForRawData = ah.nSamplesPulse;
            
            % Aligning the first TTL pulse in the recording
            alignmentOffset = isPulse(1) - TARGET_POS_TTL_IN_DATA;
            nPointsToGetForRawData = nPointsToGetForRawData + alignmentOffset;
            
            % Determining if the next pulse is there too early or not
            if alignmentOffset ~= 0
                trigger = rawFile.getData(0,tt+alignmentOffset,ah.nSamplesPulse  + TARGET_POS_TTL_IN_DATA);
                isPulse = findAllTTLPulses(trigger);
            end
            
            if length(isPulse) > ttlpp
                overshootOffset = ah.nSamplesPulse - isPulse(ttlpp+1) + TARGET_POS_TTL_IN_DATA;
                nPointsToGetForRawData = nPointsToGetForRawData - overshootOffset;
            end
            
            rawData = rawFile.getData(tt,nPointsToGetForRawData);

            % Removing the artifact
            procData = ah.processData(rawData);
            
        end
        
        % Writing the data
        newFile.appendDataToLastFile(procData);

        % Incrementing the sample counter
        tt = tt + int32(size(procData,1));

        % Checking that we're not processing data that belongs to the next stimuli
        if tt>=expEndSample(expID)
            display(['    WARNING: stimulation pulses seem to be missing in stimuli '...
                num2str(expID-1)])
            break;
        end
        
    end
    
end % processNPulses

function tt = copyData(tt,dur,expID)
    % This function copies the dur seconds of data following sample tt
    % at the end of the last new bin file.
    
    nSamplesPulse = Fs;
    secondsProcessed = 0;
    while secondsProcessed < dur
        % Getting the data
        rawData = rawFile.getData(tt,nSamplesPulse); 

        % Writing the data
        backupFile.appendDataToLastFile(rawData);

        % Incrementing the sample and pulses processed counters
        tt = tt + nSamplesPulse;
        secondsProcessed = secondsProcessed + 1;

        % Checking that we're not reading data from the next stimulus
        if tt >= expEndSample(expID)
            display(['    WARNING: strange things happened for ...stimuli '...
                num2str(expID-1)])
            break;
        end
    end
end % copyData

function blankEnd(tt,expID)
    % This function blanks everything that happened between sample tt
    % and the next stimulus. Don't need to worry about it for the last
    % stimulus.
    
if expID==length(expStartSample)
    return;
else
    nSamps = expStartSample(expID+1)-tt;
end

if nSamps>0
    while nSamps>0
        if useWhiteNoise
            blankData = int16(ones(min(nSamps,10000),1)*...
                double(rawData(end,:)) + ...
                [zeros(min(nSamps,10000),1) ...
                randn(min(nSamps,10000),512)*noiseSigma]);
        else
            blankData = int16(ones(min(nSamps,10000),1)*...
                double(rawData(end,:)));
        end
        newFile.appendDataToLastFile(blankData);
        nSamps = nSamps - 10000;
    end
else
    display(['    Warning: contrast measurement did not seem to happen between stimuli '...
        num2str(expID-1) ' and ' num2str(expID)]);
end
    
end %blankEnd

function ttl_pt = findAllTTLPulses(trigger)
    % This function finds all the TTL pulses in a trigger
    
    ttl_pt = find(diff(trigger)==-2048);
    if trigger(1) == -2048
        ttl_pt = [0 ttl_pt];
    end
    ttl_pt = int32(ttl_pt);

end % findAllTTLPulses

end % processData