function [cone_rgb, cone_spatial_profiles, cone_ideal_shapes, cone_rfs, cone_ids] =...
    summarize_cone_rfs(datarun, cell_ids, all_cone_centers, cones_labeled, all_sig_stixels, kernel_params, params)
% summarize_cone_rfs     Identify precise location and RGB profile of each cone
%
% usage:  [cone_rgb, cone_spatial_profiles, cone_ideal_shapes, cone_ids] =...
%    summarize_cone_rfs(datarun, cell_spec, all_cone_centers, cones_labeled, all_sig_stixels, params)
%
%
% arguments:  datarun - datarun struct with field specifying X
%            cell_ids - C length vector: which cells are describd in all_sig_stixels
%    all_cone_centers - Nx2 matrix: x,y locations describing approximate cone centers
%       cones_labeled - YxX matrix: matrix in which stixels corresponding to each cone have the same value,
%                           generated by matlab function bwlabel
%     all_sig_stixels - MxC matrix: which stixels were significant in each cell
%                           each column is the reshaped matrix for one cell
%       kernel_params - struct describing cone kernel.  the cone kernel is used to generate the
%                           cone spatial profile, and possibly to regress against cones.
%                           the required fields depend on the value of field 'type'
%                           for 'type' = 'dog', these are required fields
%                               kernel_params.center_radius
%                               kernel_params.surround_radius
%                               kernel_params.surround_scale
%
%              params - struct of optional parameters (see below)
%
%
% outputs:   
%
%               cone_rgb - Nx3 matrix: RGB triplets for each cone
%  cone_spatial_profiles - MxN matrix: pixel maps of the ideal shape of each cone
%      cone_ideal_shapes - N length cell array: analytic descriptions of the ideal shape of each cone 
%                               e.g. struct with parameters for a 2D gaussian
%               cone_ids - N length vector: which cone ids are described in the preceding variables.  if no roi, will be [1:num_cones]
%
%
% optional fields in params, their default values, and what they specify:
%
% centers               'fit'       how to refine cone center points
%                                       'fit' - fit a gaussian
%                                       'com' - center of mass
%                                       'fixed' - don't refine
% sensitivity           struct      params struct to pass to find_cones_in_rf, used for identifying cone center
% roi                   []          region in which to use cones
% regress               true        whether to regress the cone spatial profile against measured cone RFs to extract RGB strengths
% combine               'sum'       how to combine multiple RGB triplets into a single triplet for each cone
%
% single_cone_figure    []          figure number to plot fits of each cone serially.  if 0, make new.  if empty, don't plot
% cone_weights_figure   []          figure number to plot RGB from all cones.  if 0, make new.  if empty, don't plot
% cone_remap            []          structure with fields:
%                                       fcn       - function mapping from 3D to 2D to plot RGB from all cones
%                                       x_caption - caption for x axis
%                                       y_caption - caption for y axis
% verbose               false       display in text what's going on
%                                       
%
% note: if it exists, datarun.cones.rgb_expected will be used to plot expected cone weights compared to observed weights
%
% gauthier 2008-09
%


% * include penalty function resembling chi square
% * add color tag to each cone



% SET UP OPTIONAL ARGUMENTS

% if not specified, make params empty
if ~exist('params','var');params = [];end

% specify default parameters
defaults.centers = 'fit';
defaults.sensitivity = struct;
defaults.roi = [];
defaults.regress = true;
defaults.combine = 'sum';
defaults.single_cone_figure = [];
defaults.cone_weights_figure = [];
defaults.cone_remap = [];
defaults.robust_std_method = 5;
defaults.verbose = false;

% combine user and default parameters
params = default_params( defaults, params);


% ERROR CHECKING
if size(all_sig_stixels,2)~=length(cell_ids)
    error('number of cells in all_sig_stixels(%d) not equal to number of cells in cell_ids (%d)',...
        size(all_sig_stixels,2),length(cell_ids))
end


% BODY OF THE FUNCTION


% get expected cone RGB values
rgb_expected = cone_rgb_expected(datarun);


% set up figure
if ~isempty(params.cone_weights_figure)
    if params.cone_weights_figure > 0
        figure(params.cone_weights_figure)
    else
        params.cone_weights_figure = figure;
    end
    figure(params.cone_weights_figure);clf
end

    
    

% all_cone_centers lists cone center points for all cones which were found,
% but only those within the ROI will be anlayzed

% determine which cones are within the ROI.
% this information is stored as a list of indices to the rows all_cone_centers
if isempty(params.roi)
    % if roi is empty, use all cones
    cone_ids = 1:size(all_cone_centers,1);
else
    % if there is a ROI, get the indices of cones within it
    cone_ids = find(diag(params.roi(round(all_cone_centers(:,2)),round(all_cone_centers(:,1)))))';
end


% get list of cell numbers whose significant stixels are in all_sig_stixels
cell_indices = get_cell_indices(datarun, cell_ids);




% note the centers of just these cones
cone_centers = all_cone_centers(cone_ids,1:2);

% note number of cones
num_cones = length(cone_ids);


if params.verbose, fprintf('\nNormalizing RFs...\n'); end
for cc = cell_indices
    rf = get_rf(datarun, datarun.cell_ids(cc));
    if isempty(rf), normrf{cc} = []; continue; end    
    normrf{cc} = rf ./ robust_std(rf(:), params.robust_std_method);
end


% initialize variables (see their purposes below)
num_coi_per_cone = zeros(num_cones,1);
cone_spatial_profiles = sparse(size(all_sig_stixels,1),size(all_sig_stixels,2));
cone_rgb = zeros(num_cones,3);
cone_rfs = cell(num_cones,1);
cone_ideal_shapes = cell(num_cones,1);

% go through list of cones
start_loading = clock; % note when it started
if params.verbose, fprintf('Looking through %d cones...\n',num_cones); end
for nn = 1:num_cones
    
    % make progress tick
    %fprintf('.')
    %fprintf('%d',nn)
    
    % get the id number of this cone
    cone_id = cone_ids(nn);
    
    % get list of cells in which this was a significant cone
    
    % note which stixels belong to this cone
    cone_stixels_temp = cones_labeled==cone_id;
    
    % reshape cone_stixels to a vector, such that the Nth entry of cone_stixels_temp is from
    % the same stixel as the Nth row of all_sig_stixels
    cone_stixels_vector = reshape(cone_stixels_temp,[],1);
    
    % identify which cells have significant sampling of this cone
    % i.e. find cells in which at least one significant stixel overlaps with this cone
    cells_of_interest = find(max(all_sig_stixels(cone_stixels_vector>0,:),[],1));
    
    % ensure at least some were found
    if isempty(cells_of_interest)
        warning('cone id %d was not sampled significantly by any ganglion cell.',cone_id);
        continue
    end
    
    % note how many cells of interest were found
    num_coi_per_cone(nn) = length(cells_of_interest);
    
    
    
    % define square shaped ROI around this cone
    
    % get center point of this cone
    ctr = cone_centers(nn,1:2);
    
    % ROI radius
    rad = 1;
    
    % note the x range and y range of pixels within this square
    % take that to be the ROI
    xrng = max(round(ctr(1)-rad),1):min(round(ctr(1)+rad),size(cones_labeled,2));
    yrng = max(round(ctr(2)-rad),1):min(round(ctr(2)+rad),size(cones_labeled,1));
    
    % clear previous value
    clear cone_map
    
    
    % get stixels in the cone ROI from each cell
    
    % store in variable called cone_map, which has four dimensions
    % first three dimensions = each cell's rf in the ROI (x,y,color)
    % fourth dimension indexes the RGCs the stixels come from
    
    % initialize variables
    cone_map = zeros(length(yrng),length(xrng),3,length(cells_of_interest));
    cone_sensitivity = zeros(length(yrng),length(xrng),length(cells_of_interest));
    
    % get stixels of the ROI from the relevant RGCs
    for cc = 1:length(cells_of_interest)
        
        % get the cell number
        cell_index = cell_indices(cells_of_interest(cc));
        
        % get the rf frame
        rf = normrf{cell_index};
        
        % get pixels from the ROI
        cone_map(:,:,:,cc) = rf(yrng,xrng,:);
        
        % get cone_sensitivity
        [sig_stixels, rf_strength_out] = find_cones_in_rf(rf(yrng,xrng,:), params.sensitivity);
        cone_sensitivity(:,:,cc) = rf_strength_out;
    end
    
    
    
    
    % put sum of individual RFs of this cone into a sparse matrix the size of an entire RGC RF
    
    % initialize variable
    cone_map_sum_r = sparse(size(cones_labeled,1),size(cones_labeled,2));
    cone_map_sum_g = sparse(size(cones_labeled,1),size(cones_labeled,2));
    cone_map_sum_b = sparse(size(cones_labeled,1),size(cones_labeled,2));
    
    % enter the sum of cone_map in the appropriate location
    cone_map_sum_r(yrng,xrng) = sum(cone_map(:,:,1,:),4);
    cone_map_sum_g(yrng,xrng) = sum(cone_map(:,:,2,:),4);
    cone_map_sum_b(yrng,xrng) = sum(cone_map(:,:,3,:),4);
    
    % save to cone_rfs
    cone_rfs{nn}.cone_map_sum_r = cone_map_sum_r;
    cone_rfs{nn}.cone_map_sum_g = cone_map_sum_g;
    cone_rfs{nn}.cone_map_sum_b = cone_map_sum_b;
    
    
    % choose cone profile shape
    
    % translate cone center point to coordinates of cone_map
    ctr = [ctr(1)-min(xrng)+1  ctr(2)-min(yrng)+1];
    
    % note the ideal cone shape parameters
    switch kernel_params.type
        case 'dog'
            % save DOG parameters
            cone_ideal = rmfield(kernel_params,'type');
            
        otherwise
            error('cone kernel type ''%s'' not recognized',kernel_params.type)
    end
    
    switch params.centers
        case 'fit'  % fit gaussian to the cone_sensitivity combined across cells
    
            
            % get RF to fit
            rf_to_fit = sum(cone_sensitivity,3);
            
            if 0
                % collapse cone_map across cells and color
    
                % add up the version of the cone from each cell
                %rf_to_fit = sum(cone_map,4);
    
                % add up across colors
                %rf_to_fit = sum(rf_to_fit,3);
    
                % OLD: get vector length of each stixel
                %rf_to_fit = sqrt(sum(rf_to_fit.^2,3));
            end
            
            
            % set up parameters of the shape to fit to the cone
            
            switch kernel_params.type
                case 'dog'
                    % save DOG parameters
                    fit_params = kernel_params;
                    fit_params.effective_radius = Inf;
            end
             
            % get the sum of rf_to_fit to use as the initial guess about cone height
            rf_sum = sum(sum(rf_to_fit));
            
            % get the max of rf_to_fit to use as the initial guess about cone height
            rf_max = max(max(rf_to_fit));
            
            
            
            % fit the cone location
            
            % compute fit, using the cone center as initial center and rf_sum as the initial height
            [fit_cone_info,rf_fit] = fit_cones(rf_to_fit,[ctr rf_sum],....
                struct('cone_kernel',fit_params,'figure',[],'fig_final',[]));
            
            
            
            % save the parameters
            
            % use the fit for the cone kernel, normalizing the sum to one
            cone_profile_small  = make_gaussian('center',fit_cone_info(1:2),...
                'y_size',size(rf_to_fit,1),'x_size',size(rf_to_fit,2),'normalize','sum',...
                rmfield(fit_params,'type'));

            % save center point
            cone_ctr = fit_cone_info(1:2);

            
            
            % plot the fit and center point before and after
            if 0
                figure(11);clf;imagesc(cone_profile_small);colormap gray
                hold on; plot(fit_cone_info(:,1),fit_cone_info(:,2),'.r',ctr(1),ctr(2),'.g');
                pause
            end


        case 'com'  % take the center of mass of cone_sensitivity
            
            % get RF to fit
            rf_for_com = sum(cone_sensitivity,3);
            
            % get COM
            [com_x,com_y] = ait_centroid(rf_for_com);

            switch kernel_params.type
                case 'dog'
                    params_temp = rmfield(kernel_params,'type');
                    params_temp.center = [com_x com_y];
                    params_temp.x_size = size(cone_map,2);
                    params_temp.y_size = size(cone_map,1);
                    params_temp.normalize='sum';
            end

            % generate cone profile from DOG parameters
            cone_profile_small = make_gaussian(params_temp);
            
            % note center point
            cone_ctr = [com_x com_y];


        case 'fixed'  % don't fit, just use the location from cone_centers

            switch kernel_params.type
                case 'dog'
                    params_temp = rmfield(kernel_params,'type');
                    params_temp.center = ctr;
                    params_temp.x_size = size(cone_map,2);
                    params_temp.y_size = size(cone_map,1);
                    params_temp.normalize='sum';
            end

            % generate cone profile from DOG parameters
            cone_profile_small = make_gaussian(params_temp);
            
            % note center point
            cone_ctr = ctr;
            
            
        case 'fit neighborhood'  % fit all cones in the neighborhood simultaneously
            
            nbr_radius = 3;
            %gauss_params = {'center_radius',0.75,'effective_radius',3};
            
            
            roix = max(round(cone_centers(nn,1)-nbr_radius),1):...
                min(round(cone_centers(nn,1)+nbr_radius),datarun.stimulus.field_width);
            roiy = max(round(cone_centers(nn,2)-nbr_radius),1):...
                min(round(cone_centers(nn,2)+nbr_radius),datarun.stimulus.field_height);



            % identify RGCs in the ROI

            % ROI in graphic form
            roi=zeros(datarun.stimulus.field_height,datarun.stimulus.field_width);
            roi(roiy,roix)=1;

            % reshape to compare to all_sig_stixels
            roi = reshape(roi,[],1);

            % find cells in there
            roicells = find(any(all_sig_stixels&repmat(roi,1,size(all_sig_stixels,2)),1));

            % plot to verity
            if 0
                for cc=1:length(roicells)
                    figure(4);clf;
                    imagesc(reshape(all_sig_stixels(:,roicells(cc)),datarun.stimulus.field_height,datarun.stimulus.field_width))
                    axis image
                    pause(0.5)
                end
            end
            
            

            % get a sensitivity map of each such RGC in this region

            clear rfs roicenters

            rfs = zeros(length(roiy),length(roix),length(roicells));
            cell_indices = get_cell_indices(datarun,cell_ids);

            % go through each found cell
            for cc=1:length(roicells)

                % get the rf
                rf = get_rf(datarun,datarun.cell_ids(cell_indices(roicells(cc))));

                % get the roi
                rf = rf(roiy,roix,:)/robust_std(reshape(rf,[],1));

                % combine across color channels
                rfs(:,:,cc) = sum(rf,3);
            end


            
            % get cone center points, translate to this region

            % get center points
            %cp=datarun.cones.centers;
            cp=cone_centers;

            % find ones in this region
            center_indices = find(cp(:,1)>min(roix)-0.5 & cp(:,1)<max(roix)+0.5 & cp(:,2)>min(roiy)-0.5 & cp(:,2)<max(roiy)+0.5);
            
            % note which one is the cone of interest
            this_cone_index = find(center_indices==cone_id);
            if isempty(this_cone_index)
                error('cone id %d was not found in its own neighborhood!',cone_id)
            end

            % keep them
            roicenters=cp(center_indices,1:2);

            % subtract to fit in ROI
            roicenters = roicenters - repmat([min(roix) min(roiy)],size(roicenters,1),1) + 1;

            % plot RGCs with center points overlaid
            if 0
                for cc=1:length(roicells)
                    figure(2);clf;colormap gray
                    imagesc(rfs(:,:,cc))
                    hold on; plot(roicenters(:,1),roicenters(:,2),'.r','MarkerSize',25)
                    pause(0.5)
                end
            end



            % fit gaussians

            % prepare initial cone parameters
            cone_initial = roicenters;

            % estimate heights for each cone in each RF
            for cc=1:size(roicenters,1)
                % make little gaussian of the cone
                conerf = make_gaussian('x_size',size(rfs,2),'y_size',size(rfs,1),...
                    'center',roicenters(cc,:),rmfield(kernel_params,'type'),'normalize','sum');

                % estimate height for each RF
                for rr=1:length(roicells)
                    cone_initial(cc,rr+2) = reshape(rfs(:,:,rr),[],1)'/reshape(conerf,[],1)';
                end
            end

            % fit them
            [fit_cone_info,rf_fit] = fit_cones_in_many_RFs(rfs,cone_initial,'figure',[],...
                'cone_kernel',kernel_params,'optim',{'TolX',0.1,'Display','off','MaxIter',50});

            
            
            
            % save the parameters

            % save center point
            cone_ctr = fit_cone_info(this_cone_index,1:2) + [min(roix) min(roiy)] + [-min(xrng)+1 -min(yrng)+1] - 1;
            
            % use the fit for the cone kernel, normalizing the sum to one
            cone_profile_small  = make_gaussian('center',cone_ctr,...
                'y_size',length(yrng),'x_size',length(xrng),'normalize','sum',...
                rmfield(kernel_params,'type'));
            
            
            
            
            
            
            
        otherwise
            error('center point finding algorithm ''%s'' not recognized.',params.centers)

    end
    
    
    
    % save the cone spatial profile, both in pixels and analytically
    
    % put the ideal cone shape (cone_profile_small) in a sparse matrix as big as a whole sta
    ideal_cone_large = sparse(datarun.stimulus.field_height,datarun.stimulus.field_width);
    ideal_cone_large(yrng,xrng) = cone_profile_small;

    % save this ideal cone profile in the final output matrix
    cone_spatial_profiles(:,nn) = reshape(ideal_cone_large,[],1);
    
    % note the cone profile center point (translated to stimulus coordinates)
    cone_ideal.center = [cone_ctr(1)+min(xrng)-1  cone_ctr(2)+min(yrng)-1];
    
    % put the analytic description in the final output cell array
    cone_ideal_shapes{nn} = cone_ideal;
    
    
    % compare before and after
    if params.verbose
        fprintf('cone id %d: from [%0.2f %0.2f] to [%0.2f %0.2f]\n',cone_id,...
            all_cone_centers(cone_id,1),all_cone_centers(cone_id,2),cone_ideal.center(1),cone_ideal.center(2))
    end


    if strcmpi(datarun.stimulus.independent,'nil')
        continue;
    end

    % set parameters for getting RGB triplet
    
    % clear any previous value
    clear rgb_params
    
    % pass two arguments verbatim
    rgb_params.combine = params.combine;
    rgb_params.figure = params.single_cone_figure;
    
    % pass in expected cone weights
    rgb_params.cone_expected = rgb_expected;

    % pass in shape of cone, if regression is desired
    if params.regress
        rgb_params.regress = struct('type','given','profile',cone_profile_small);
    else
        rgb_params.regress = [];
    end
        
    
    
    % get RGB triplet
    
    cone_rgb(nn,:) = rgb_from_cones(cone_map,rgb_params);

    
    

    % plot RGB values from all cones so far
    
    % be sure plotting is desired, and a function to remap to 2D exists
    if ~isempty(params.cone_weights_figure) && ~isempty(params.cone_remap)

        % map 3D cone weights to 2D
        remapped_rgb = params.cone_remap.fcn(cone_rgb(1:nn,1:3));

        % plot in 2D
        figure(params.cone_weights_figure);clf
        plot(remapped_rgb(:,1),remapped_rgb(:,2),'.k')
        xlabel(params.cone_remap.x_caption)
        ylabel(params.cone_remap.y_caption)

        % plot expected gun strengths (if present in datarun)
        if isfield(datarun,'cones') && isfield(datarun.cones,'rgb_expected') && ~isempty(datarun.cones.rgb_expected)
            % get L and M center in remapped coordinates
            L_ctr = params.cone_remap.fcn(rgb_expected.L);
            M_ctr = params.cone_remap.fcn(rgb_expected.M);
            % add them to the plot
            hold on
            plot(L_ctr(1),L_ctr(2),'.r','MarkerSize',25)
            plot(M_ctr(1),M_ctr(2),'.g','MarkerSize',25)
        end

        % set axes
        set(gca,'XLim',[-.5 1.5],'YLim',[-.5 1.5])

        drawnow
    end
    
    

end % for nn = 1:num_cones



if params.verbose
    fprintf('Done (%0.1f seconds)\n',etime(clock,start_loading));
end


